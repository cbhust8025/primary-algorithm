# 牛客网模拟笔试 2017-0616
>记录编程题,ac代码附最后。
## 01 黑白卡片
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛有n张卡片排成一个序列.每张卡片一面是黑色的,另一面是白色的。初始状态的时候有些卡片是黑色朝上,有些卡片是白色朝上。牛牛现在想要把一些卡片翻过来,得到一种交替排列的形式,即每对相邻卡片的颜色都是不一样的。牛牛想知道最少需要翻转多少张卡片可以变成交替排列的形式。 
##### 输入  
>输入包括一个字符串S,字符串长度length(3 ≤ length ≤ 50),其中只包含'W'和'B'两种字符串,分别表示白色和黑色。整个字符串表示卡片序列的初始状态。
##### 输出  
>输出一个整数,表示牛牛最多需要翻转的次数。

#### 样例输入
```
BBBW
```
#### 样例输出
```
1
```

## 02 黑化的牛牛
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛变得黑化了,想要摧毁掉地球。但他忘记了开启地球毁灭器的密码。牛牛手里有一个字符串S,牛牛还记得从S中去掉一个字符就恰好是正确的密码,请你帮牛牛求出他最多需要尝试多少次密码。
如样例所示S = "ABA",3个可能的密码是"BA", "AA", "AB".
当S = "A", 牛牛唯一可以尝试的密码是一个空的密码,所以输出1. 
##### 输入  
>输入包括一个字符串S,字符串长度length(1 ≤ length ≤ 50),其中都是从'A'到'Z'的大写字母。
##### 输出  
>输出一个整数,表示牛牛最多需要尝试的密码次数。

#### 样例输入
```
ABA
```
#### 样例输出
```
3
```

## 03 膨胀的牛牛
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛以草料为食。牛牛有一天依次遇到n堆被施展了魔法的草料,牛牛只要遇到一堆跟他当前相同大小的草料,它就会把草料吃完,而使自己的大小膨胀一倍。一开始牛牛的大小的是A,然后给出牛牛依次遇到的n堆草料的大小。请计算牛牛最后的大小。 
##### 输入  
>输入包括两行,第一行包含两个整数n和A(1 ≤ n ≤ 200, 1 ≤ A ≤ 1,000,000,000)
第二行包括n个整数,表示牛牛依次遇到的草料堆大小a_i(1 ≤ a_i ≤ 1,000,000,000)
##### 输出  
>输出一个整数,表示牛牛最后的大小。

#### 样例输入
```
5 1
2 1 3 1 2
```
#### 样例输出
```
4
```

## 04 序列交换
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛有一个长度为n的整数序列s,羊羊要在牛牛的序列中选择不同的两个位置,然后交换这两个位置上的元素。现在需要求出羊羊交换后可以得到的不同的序列个数。(注意被交换的两元素值可能相同)。
如序列{1, 47},输出1.羊羊必须交换仅有的两个元素,得到序列{47, 1}。羊羊必须交换,不能保留原有的序列。
{1, 2, 1},输出3.羊羊通过交换可以得到{2, 1, 1},{1, 1, 2},{1, 2, 1}这三个序列。 
##### 输入  
>输入包括两行,第一行为一个整数n(2 ≤ n ≤ 50),即序列的长度。
第二行n个整数,表示序列的每个元素a_i(1 ≤ a_i ≤ 50),以空格分割。
##### 输出  
>输出一个整数,表示羊羊可以得到的不同的序列个数

#### 样例输入
```
3
1 2 1
```
#### 样例输出
```
3
```

## 05 丑陋的字符串
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛喜欢字符串,但是他讨厌丑陋的字符串。对于牛牛来说,一个字符串的丑陋值是字符串中相同连续字符对的个数。比如字符串“ABABAABBB”的丑陋值是3,因为有一对"AA"和两对重叠的"BB"。现在给出一个字符串,字符串中包含字符'A'、'B'和'?'。牛牛现在可以把字符串中的问号改为'A'或者'B'。牛牛现在想让字符串的丑陋值最小,希望你能帮帮他。 
##### 输入  
>输入包括一个字符串s,字符串长度length(1 ≤ length ≤ 50),字符串只包含'A','B','?'三种字符。
##### 输出  
>输出一个整数,表示最小的丑陋值

#### 样例输入
```
A?A
```
#### 样例输出
```
0
```

## 06 庆祝61
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐,牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小,牛老师犯了难,希望你能帮帮他。
如样例所示:
当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5,其他排列不会得到更优的解 
##### 输入  
>输入包括两行,第一行为一个正整数n(3 ≤ n ≤ 20)
第二行为n个整数h_i(80 ≤ h_i ≤ 140),表示每个小朋友的身高。
##### 输出  
>输出一个整数,表示满足条件下的相邻小朋友身高差的最大值。
#### 样例输入
```
4
100 103 98 105
```
#### 样例输出
```
5
```

## 07 随机的机器人
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
有一条无限长的纸带,分割成一系列的格子,最开始所有格子初始是白色。现在在一个格子上放上一个萌萌的机器人(放上的这个格子也会被染红),机器人一旦走到某个格子上,就会把这个格子涂成红色。现在给出一个整数n,机器人现在会在纸带上走n步。每一步,机器人都会向左或者向右走一个格子,两种情况概率相等。机器人做出的所有随机选择都是独立的。现在需要计算出最后纸带上红色格子的期望值。 

##### 输入  
>输入包括一个整数n(0 ≤ n ≤ 500),即机器人行走的步数。

##### 输出  
>输出一个实数,表示红色格子的期望个数,保留一位小数。

#### 样例输入
```
4
```
#### 样例输出
```
3.4
``` 
## 08  逃离农场
* 时间限制：1秒
* 内存限制：32768K
### 题目描述：
牛牛在农场饲养了n只奶牛,依次编号为0到n-1, 牛牛的好朋友羊羊帮牛牛照看着农场.有一天羊羊看到农场中逃走了k只奶牛,但是他只会告诉牛牛逃走的k只奶牛的编号之和能被n整除。你现在需要帮牛牛计算有多少种不同的逃走的奶牛群。因为结果可能很大,输出结果对1,000,000,007取模。
例如n = 7 k = 4:
7只奶牛依次编号为0到6, 逃走了4只
编号和为7的有:{0, 1, 2, 4}
编号和为14的有:{0, 3, 5, 6}, {1, 2, 5, 6}, {1, 3, 4, 6},{2, 3, 4, 5}
4只牛的编号和不会大于18,所以输出5. 
##### 输入  
>输入包括一行,两个整数n和k(1 ≤ n ≤ 1000),(1 ≤ k ≤ 50),以空格分割。
##### 输出  
>输出一个整数表示题设所求的种数。

#### 样例输入
```
7 4
```
#### 样例输出
```
5
```

# 牛客网模拟笔试 2017-0519 AC代码：
## 01 黑白卡片
```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

int dpforstring(string ss) {
	// 通过dp方法计算字符串ss需要翻转的最少次数
	// 由于此时字符串为一维，dp数组也为一维，使用优化算法，可以将dp数组压缩 成一个数count
	int count = 0;//从字符串开始统计需要修改的次数，第一个字符默认不修改，所以字符串长度小于或等于1，直接返回0即可
	if (ss.length() <= 1)
		return count;
	int ic = 'W' + 'B';
	for (int i = 1;i < ss.length();i++)
	{//由于不修改第一个字符，所以从第二个字符开始统计修改次数，如果当前字符和前一个字符不同，则修改
		if (ss[i] == ss[i - 1])
		{
			ss[i] = char(ic - ss[i - 1]);
			count++;
		}
	}
	return count;
}

int main()
{
	/* 01 
	[编程题] 黑白卡片
	时间限制：1秒
	空间限制：32768K
	牛牛有n张卡片排成一个序列.每张卡片一面是黑色的,另一面是白色的。初始状态的时候有些卡片是黑色朝上,有些卡片是白色朝上。牛牛现在想要把一些卡片翻过来,得到一种交替排列的形式,即每对相邻卡片的颜色都是不一样的。牛牛想知道最少需要翻转多少张卡片可以变成交替排列的形式。
	输入描述:
	输入包括一个字符串S,字符串长度length(3 ≤ length ≤ 50),其中只包含'W'和'B'两种字符串,分别表示白色和黑色。整个字符串表示卡片序列的初始状态。


	输出描述:
	输出一个整数,表示牛牛最多需要翻转的次数。

	输入例子:
	BBBW

	输出例子:
	1
	*/
	string ss;
	cin >> ss;
	int count_n = dpforstring(ss);
	reverse(ss.begin(), ss.end());
	cout << min(count_n, dpforstring(ss));
	system("pause");
	return 0;
}
```

## 02 黑化的牛牛
```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

int countforstring(string ss)
{
	//统计字符串去除一个字符后的不重复可能情况总数
	if (ss.length() == 1)
		return 1;
	int count = 1;  // 至少有一种情况是去除第一个字符得到的密码
	for (int i = 1;i < ss.length();i++)
	{//从i=1开始，如果当前字符与前一个字符相同，则计数器不加一，反之加一计数
		if (ss[i] != ss[i - 1])
			count++;
	}
	return count;
}

int main()
{
	/* 01 
	[编程题] 黑化的牛牛
	时间限制：1秒
	空间限制：32768K
	牛牛变得黑化了,想要摧毁掉地球。但他忘记了开启地球毁灭器的密码。牛牛手里有一个字符串S,牛牛还记得从S中去掉一个字符就恰好是正确的密码,请你帮牛牛求出他最多需要尝试多少次密码。
	如样例所示S = "ABA",3个可能的密码是"BA", "AA", "AB".
	当S = "A", 牛牛唯一可以尝试的密码是一个空的密码,所以输出1. 
	输入描述:
	输入包括一个字符串S,字符串长度length(1 ≤ length ≤ 50),其中都是从'A'到'Z'的大写字母。


	输出描述:
	输出一个整数,表示牛牛最多需要尝试的密码次数。

	输入例子:
	ABA

	输出例子:
	3
	*/
	// 此题解题思路为：最大尝试密码次数即为当前字符串长度减一，也就是所有可能的密码总数，但是由于存在重复的密码
	// 所以如果在去除字符的时候，相同连续的去除同一个字符，则会出现相同的可能密码，在计算的时候去除此类情况即可得到正确答案。

	string ss;
	cin >> ss;
	cout << countforstring(ss);
	system("pause");
	return 0;
}
```

## 03 膨胀的牛牛
```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

int main()
{
	/* 01 
	[编程题] 膨胀的牛牛
	时间限制：1秒
	空间限制：32768K
	牛牛以草料为食。牛牛有一天依次遇到n堆被施展了魔法的草料,牛牛只要遇到一堆跟他当前相同大小的草料,它就会把草料吃完,而使自己的大小膨胀一倍。一开始牛牛的大小的是A,然后给出牛牛依次遇到的n堆草料的大小。请计算牛牛最后的大小。 
	输入描述:
	输入包括两行,第一行包含两个整数n和A(1 ≤ n ≤ 200, 1 ≤ A ≤ 1,000,000,000)
	第二行包括n个整数,表示牛牛依次遇到的草料堆大小a_i(1 ≤ a_i ≤ 1,000,000,000)


	输出描述:
	输出一个整数,表示牛牛最后的大小。

	输入例子:
	5 1
	2 1 3 1 2

	输出例子:
	4
	*/
  // 送分题，排序后依次遍历即可
	long n, A;
	cin >> n >> A;
	vector<long> viA(n, 0);
	for (int i = 0;i < n;i++)cin >> viA[i];
	sort(viA.begin(), viA.end(), [](long a, long b) {return a < b;});
	for (int i = 0;i < n;i++)
	{
		if (viA[i] == A)
		{
			A *= 2;
		}
	}
	cout << A;
	system("pause");
	return 0;
}
```

## 04 序列交换
```C++
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;

int main()
{
	/* 01 
	[编程题] 序列交换
	时间限制：1秒
	空间限制：32768K
	牛牛有一个长度为n的整数序列s,羊羊要在牛牛的序列中选择不同的两个位置,然后交换这两个位置上的元素。现在需要求出羊羊交换后可以得到的不同的序列个数。(注意被交换的两元素值可能相同)。
	如序列{1, 47},输出1.羊羊必须交换仅有的两个元素,得到序列{47, 1}。羊羊必须交换,不能保留原有的序列。
	{1, 2, 1},输出3.羊羊通过交换可以得到{2, 1, 1},{1, 1, 2},{1, 2, 1}这三个序列。 
	输入描述:
	输入包括两行,第一行为一个整数n(2 ≤ n ≤ 50),即序列的长度。
	第二行n个整数,表示序列的每个元素a_i(1 ≤ a_i ≤ 50),以空格分割。


	输出描述:
	输出一个整数,表示羊羊可以得到的不同的序列个数

	输入例子:
	3
	1 2 1

	输出例子:
	3
	*/
	// 经典回溯算法应用，只不过追溯的深度为1，所以简化了计算过程
	// 注意两点：1、必须进行交换，且只能进行一次交换，所以原序列不保存，如果交换出跟原序列相同的序列也算一种
	// 2、去重，可能存在三个或三个以上的重复数字，此时进行重复数字的交换得到的结果相同，所以需要对交换后的序列进行去重
	// 考虑使用set 容器来进行去重
	int n;
	cin >> n;
	vector<int> vi(n, 0);
	for (int i = 0;i < n;i++)cin >> vi[i];
	set<vector<int>> svi; // 将交换结果存入svi，自动进行去重
	for (int i = 0;i < n;i++)
	{
		for (int j = i + 1;j < n;j++)
		{//将当前i索引的值与j索引的值进行交换，所以j = i + 1,
			swap(vi[i], vi[j]);
			svi.insert(svi.end(), vi); // 将交换结果存入svi中
			swap(vi[i], vi[j]); // 回溯算法的核心操作，每次回溯回来之后重置追溯前的操作
		}
	}
	cout << svi.size();
	system("pause");
	return 0;
}
```

## 05 丑陋的字符串
```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

int main()
{
	/* 01 
	[编程题] 丑陋的字符串
	时间限制：1秒
	空间限制：32768K
	牛牛喜欢字符串,但是他讨厌丑陋的字符串。对于牛牛来说,一个字符串的丑陋值是字符串中相同连续字符对的个数。比如字符串“ABABAABBB”的丑陋值是3,因为有一对"AA"和两对重叠的"BB"。现在给出一个字符串,字符串中包含字符'A'、'B'和'?'。牛牛现在可以把字符串中的问号改为'A'或者'B'。牛牛现在想让字符串的丑陋值最小,希望你能帮帮他。
	输入描述:
	输入包括一个字符串s,字符串长度length(1 ≤ length ≤ 50),字符串只包含'A','B','?'三种字符。


	输出描述:
	输出一个整数,表示最小的丑陋值

	输入例子:
	A?A

	输出例子:
	0
	*/
	// 这道题，主要难点在于不能确定问号的值是多少，会对最后的丑陋值造成影响，但是列出所有可能的情况，发现
	// 只要将问号置成与前面一个字符，或者后面一个字符不相同的字符即可使得丑陋值最小，最后统计其丑陋值即可
	string ss;
	cin >> ss;
	//　需要将第一族问号（如果第一个问号开始有连续n个问号，则此组问号的丑陋值为0,并将其删除）进行处理
	while (ss.length() > 0 && ss[0] == '?')
		ss.erase(ss.begin());
	int count = 0; // 计算丑陋值
	int si = 'A' + 'B';
	for (int i = 1;i < ss.length();i++)
	{//第一个字符不需要考虑
		if (ss[i] == '?') // 如果当前的字符为“?”
		{
			ss[i] = char(si - ss[i - 1]);
		}
		else if (ss[i] == ss[i - 1])
			count++;
	}
	cout << count;
	system("pause");
	return 0;
}
```

## 06 庆祝61
```C++
#include<iostream>
#include<vector>
#include<list>
#include<algorithm>
using namespace std;

int main()
{
	/* 01 
	[编程题] 庆祝61
	时间限制：1秒
	空间限制：32768K
	牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐,牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小,牛老师犯了难,希望你能帮帮他。
	如样例所示:
	当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5,其他排列不会得到更优的解 
	输入描述:
	输入包括两行,第一行为一个正整数n(3 ≤ n ≤ 20)
	第二行为n个整数h_i(80 ≤ h_i ≤ 140),表示每个小朋友的身高。


	输出描述:
	输出一个整数,表示满足条件下的相邻小朋友身高差的最大值。

	输入例子:
	4
	100 103 98 105

	输出例子:
	5
	*/
	// 这道题的解题思路为：由于这么多小朋友，如果我们从排列的角度来解答，会变得很复杂，无法下手
	// 所以我们从插入的思路来解答，将所有的小朋友按照身高进行排队，然后选取一个起点，从小朋友的队伍里依次放入小朋友到圆圈中
	// 难点有二：1、如何选取第一个小朋友(由于进行了排序，所以选取最小和最大是同样，选取中间的任何小朋友是另一种情况)
	// 2、插入的逻辑，假设我们选择的是最小的小朋友，按照贪心算法的逻辑，我们需要依次从小到大把小朋友放到这个小朋友的两边
	// 也就是如果我选取了最小的小朋友98，我需要依次将顺序100， 和103放到两边，然后继续此种操作，保持100以及与100距离为2的数字顺位放下
	// 最后就是105 100 98 103这样的放置结果，如果还有比105更大的就往103右边放置，直至放置完毕，对于这样的操作，我们需要用到的数据结构为list，即双向链表封装结构
	// 根据以上的算法，实质上是求排序后的数组中间隔两个数的最大差值，简化之后不需要使用list数据结构直接求差值即可
	int n;
	cin >> n;
	vector<int> vi(n, 0);
	for (int i = 0; i < n;i++)
	{
		cin >> vi[i];
	}
	sort(vi.begin(), vi.end(), [](int a, int b) {return a < b;});
	int mindev = vi[2] - vi[0];
	for (int i = 0;i < n - 2;i++)
	{
		mindev = max(mindev, vi[i + 2] - vi[i]);
	}
	cout << mindev;
	system("pause");
	return 0;
}
```
