# 美图秀秀 笔试题 2017/04/16 19:00-21:00
>记录编程题,ac代码附最后。
## 01 小明的烦恼(也叫建筑抢修)
* 时间限制：C/C++语言 1000MS；其他语言 3000MS
* 内存限制：C/C++语言 65536KB；其他语言 589824KB
### 题目描述：
小明开了家饮食店。每到用餐点，都会收到一批的外卖订单（为了方便，假设订单同时到达）。每个用户
都不希望等太久，所以当他们在预期的时间内外卖还没送到时，就会给小明的店评上差评。小明想知道如何去完成这些订单，才能使得获得的差评最少。
##### 输入  
>第一行是一个整数N，表示有N个订单。
接下来N行每行两个整数T1、T2，表示完成这份订单并送到用户手中需要T1的时间，且必须在时间区间[0,T2]这段时间内完成，否则用户就会很生气地给一个差评。
数据范围：N<=100000，对于每一个订单0<T1<=T2< 2^31
##### 输出  
>小明收到的差评最少是多少。

#### 样例输入
```
4
100 300
200 1300
1000 1250
2000 3200
```
#### 样例输出
```
1
```
#### Hint
> [0,100]时间内完成订单1，因为100<=300故可以收到好评;  
> 参考案例： [建筑抢修](http://blog.csdn.net/getsum/article/details/52049148)、[建筑抢修](http://m.blog.csdn.net/article/details?id=27108127)

## 02 保安的烦恼
* 时间限制：C/C++语言 1000MS；其他语言 3000MS
* 内存限制：C/C++语言 65536KB；其他语言 589824KB
### 题目描述：
小强是公寓某栋宿舍楼保安，他的职责是一到晚上12点以后就将大门锁住，但是每天12点以后出入宿舍的学生很多，而且一旦有学生出入的时候就必须去开门然后再锁上，一直重复这样的工作效率很低，他希望一个晚上开门的总次数尽量达到最少，于是他每次开门让在门口等待的学生出入之后，再在门口多等R分钟，而且在这段时间内到达门口的学生可无需等待即可直接出入，然后才关上门。比如多等的时间R=2，且开门的时刻为t=5，则t=5或之前时刻来的学生可直接出入并且在t=6,7时刻来的学生仍可直接出入；如果R=0表示每次保安一开门所有在门口等待的学生和这个时间到达的学生可以直接出入然后马上关上门。
经过了长时间的观察，他推算出了所有学生出入大门的规律，并且他希望在总开门次数不超过M的情况下，使得所有出入的学生的总等待时间最短，毕竟等待还是让学生们感到很不高兴的。
现在请你编个程序求出当开门次数不超过M的情况下最短的总等待时间。
##### 输入  
>输入数据的第一行包含三个整数N M R (1<=N,M<=100, 0<=R<=1,000,000)， 表示总共要出入的学生有N个，开门总次数不超过M，每次开门的时候保安在门口继续等待的时间为R。
接下来一行N个整数ti(0< ti<=1,000,000)，分别表示N个学生的进出时刻。
##### 输出  
>输出学生的最少的总等待时间T。

#### 样例输入
```
5 2 0
1 9 3 8 2
```
#### 样例输出
```
4
```
#### Hint
> 对于样例，保安小强可以选择在t=3和t=9的时间开门。


```C++
//meitu01.cpp
#include<iostream>
#include<stdlib.h>
#include<vector>
#include<algorithm>
#include<queue>
using namespace std;

/*
小明的烦恼
时间限制：C/C++语言 1000MS；其他语言 3000MS
内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述：
小明开了家饮食店。每到用餐点，都会收到一批的外卖订单（为了方便，假设订单同时到达）。每个用户都不希望等太久，所以当他们在预期的时间内外卖还没送到时，就会给小明的店评上差评。小明想知道如何去完成这些订单，才能使得获得的差评最少。
输入
第一行是一个整数N，表示有N个订单。

接下来N行每行两个整数T1、T2，表示完成这份订单并送到用户手中需要T1的时间，且必须在时间区间[0,T2]这段时间内完成，否则用户就会很生气地给一个差评。

数据范围：N<=100000，对于每一个订单0<T1<=T2< 2^31

输出
小明收到的差评最少是多少。

样例输入
4
100 300
200 1300
1000 1250
2000 3200
样例输出
1

Hint
[0,100]时间内完成订单1，因为100<=300故可以收到好评；
*/

int main()
{
	int  N;
	cin >> N;
	int max = 0;
	vector<vector<int>> dingdan;
	for (int i = 0;i < N;i++)
	{
		vector<int> temp(2,0);
		cin >> temp[0] >> temp[1];
		dingdan.push_back(temp);
		if (temp[1] > max)
			max = temp[1];
		temp.clear();
	}
	sort(dingdan.begin(), dingdan.end(), [](vector<int> a, vector<int> b) {return a[1] < b[1];});
	long long time = 0;
	int count = 0;
	priority_queue<int> q;
	for (int i = 0;i < N;i++)
	{
		if (time + dingdan[i][0] <= dingdan[i][1])
		{
			time += dingdan[i][0];
			q.push(dingdan[i][0]);
		}
		else if (!q.empty() && q.top() > dingdan[i][0])
		{
			time += dingdan[i][0] - q.top();
			q.pop();
			q.push(dingdan[i][0]);
		}

	}
	cout << N - q.size() << endl;
	system("pause");
	return 0;
}
```
