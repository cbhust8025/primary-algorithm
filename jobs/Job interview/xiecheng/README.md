# 携程笔试
>记录编程题
## 01 乘积最大
* 时间限制：C/C++语言 3MS；其他语言 2003MS
* 内存限制：C/C++语言 65536KB；其他语言 589824KB
### 题目描述：
有一个整数n，将n分解成若干个不同自然数之和，问如何分解能使这些数的乘积最大，输出这个乘积m
输入
一个整数，不超过50
输出
一个整数

#### 样例输入
```
15
```
#### 样例输出
```
144
```

## 02 拼图
* 时间限制：C/C++语言 3000MS；其他语言 5000MS
* 内存限制：C/C++语言 10240KB；其他语言 534528KB
### 题目描述：
拼图，是一个老少皆宜的益智游戏，在打乱的3*3的范围中，玩家只能每次将空格(0)和相邻的数字格（上、下、左、右）交换，最终调整出一个完整的拼图。
完整拼图为：
```
1 2 3  
4 5 6  
7 8 0 
```
输出:还原完整拼图的最少移动次数。如不需要调整，则输出0；如无解，则输出-1。  
输出:一个整数  
例如：  
```
0 1 3  
4 2 5  
7 8 6
```
依次移动1,2,5,6，即可还原为正确拼图，移动次数为4。
#### 样例输入  
```
0 1 3  
4 2 5  
7 8 6
```
#### 样例输出  
```
4
```
## 04 股票交易
* 时间限制 C/C++语言：1000MS其它语言：3000MS
* 内存限制 C/C++语言：10240KB其它语言：534528KB
### 题目描述：一个一维数组，记录n天中每天的携程股价。股市交易规则如下：
* 一天只能有买进或者卖出一种操作，也可以不做任何操作，卖出时价格减买入时价格即为收
* 每次卖出操作后有冻结期，k天之后才能进行下一次买进操作（k>=1）
* 买进之后必须卖出才能再次买进
### 设计一个算法，找到交易收益最大化的买进卖出策略，返回最后的最大收益值

输入
一维正整数数组，表示每天股价
正整数k，表示冷冻期
输出
返回最大收益

#### 样例输入
```
int[] sotckPrice = {1,2,3,5,2,6,3,7};
int k = 2;
8（表示数组长度）
1（开始依次输入数组元素）
2
3
5
2
6
3
7
2（输入k）
```
#### 样例输出
```
8
(1买进，5卖出，3买进，7卖出，收益最大为8)
```
```C++
//携程第一题ac解
#include <iostream> 
#include<vector>
#include <math.h>
#include<stdlib.h>
#include <iomanip>
using namespace std;
int maxNum(int k) {
	if (k <= 2)
	{
		return k;
	}
	if (k == 3)
	{
		return 2;
	}
	if (k == 4)
	{
		return 3;
	}
	int i = 0;
	int res = 1;
	int in = 2;
	vector<int> arr(30,0);
	while (k >= in)
	{
		arr[i++] = in;
		k -= in;
		in++;
	}
	if (k>0)
	{
		if (k == arr[i - 1])
		{
			arr[i - 1]+=1;
			k--;
		}
		for(int j = 0;j < k;j++)
		{
			arr[i - 1 - j]+=1;
		}
	}
	for (int j = 0;j < arr.size();j++)
	{
		if (arr[j] != 0)
		{
			res *= arr[j];
		}
	}
	return res;
}
int main() {
	int res;
	int k;
	//cin >> k;
	for (int i = 1;i < 20;i++)
	{
		res = maxNum(i);
		cout << i<<":"<<res << endl;
	}
	
	//system("pause");
	return 0;
}
```

```C++
//股票交易AC解
#include"VectorHelper.h"
#include<algorithm>
int main()
{
	int n;
	cin >> n;
	vector<int> sotckPrice(n, 0);
	for (int i = 0;i<n;i++)cin >> sotckPrice[i];
	int k;
	cin >> k;
	int cur = -1000;
	int ans = 0;
	vector<int> dp(sotckPrice.size() + 1, 0);//dp数组，下标为天数，物理意义：我手中当前的现钱，准备花出去，在每天操作之前。
	for (int i = 1;i < dp.size();i++)//第0天肯定是0，从第一天开始炒股
	{
		//想要的肯定是钱越多越好，所以在昨天的现钱、在最近一次（最大化余额，最小股价）买进操作加上第i天卖出手中的股票中抉择，取大值
		//三种操作：
		//买入：买入的话由cur体现，并在未来的天数中对dp[i+1...]进行修正，所以对当前的dp[i]无影响;
		//卖出：之前买入的cur + 当前股价的卖出sotckPrice[i-1]
		//不做任何操作：跟昨天一样，dp[i-1]
		dp[i] = max(dp[i - 1], cur + sotckPrice[i - 1]);


		//当前操作有卖出已经买到的股票，以及买进当前的股票，还有不做任何操作。
		//由于k天前后，cur从买进最低价股票，和i-k天时候的财产来购买当前的股票。所以cur永远都是进行买进的操作。
		//由于有冰冻期k天
		//所以前k天肯定不会有买不了股票的行为，保存出现过的股票最低值，也就是我以后在k天之前能够套现的较大值。
		//同样，可以将cur理解为负债，在没有成为正数的时候，开始因为现金为0，所以负债来进行买股票，尽可能让负债越低越好
		//cur同样也是当天进行操作完了之后的剩余现钱。
		//从第i(i>=k)天开始，因为有卖出冰冻期，所以存在第i-k天卖出接着在k天冷冻期后进行购买第i天的股票的情况
		//另外由于cur保存的是上一次操作完了之后剩余的现金，所以这两个值中取大者可以保证在上一次操作和这一次操作完了之后
		//我剩余的钱最多，也即买的肯定是最低价的股票（找到最低价股票就换）
		if (i >= k)
			cur = max(cur, dp[i - k] - sotckPrice[i - 1]);
		else
			cur = max(cur, -sotckPrice[i - 1]);
		ans = max(ans, dp[i]);
	}
	VectorHelper::printVector(dp);
	cout << ans << endl;
	system("pause");
	return 0;
}

```
