# 八皇后--->N-皇后问题（回溯法的经典应用）
### 1、问题描述：N皇后问题是一个经典的问题，在一个N*N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。
### 2、解决思路：应用回溯法进行解决，回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。
> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 在现实中，有很多问题往往需要我们把其所有可能穷举出来，然后从中找出满足某种要求的可能或最优的情况，从而得到整个问题的解。回溯算法就是解决这种问题的“通用算法”，有“万能算法”之称。
### 3、N皇后问题过程详解：
* 1）算法开始，清空棋盘，当前行为第一行，当前列为第一列;
* 2）在当前行，当前列的位置上判断是否满足条件（即保证经过这一行、这一列与这一条斜线上没有两个皇后），若不满足，则跳至第四步。
* 3）若当前位置满足条件的情形下：
>* 在当前位置放下皇后，若当前行是最后一行，记录下此解。
>* 若当前行不是最后一行，当前行设为下一行，当前列设为下一行的第一列；
>* 若当前行是最后一行，当前列不是最后一列，当前列设为下一列；
>* 若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的的棋盘，然后当前行设为上一行，当前列设为当前行的下一个待测位置。
>* 完成后返回到第二步。
* 4）在当前位置不满足条件的情形下：
>* 若当前列不是最后一列，即设当前列为下一列
>* 若当前列是最后一列，回溯，若当前行为第一行，算法失败并退出，否则，清空当前行及以下各行的的棋盘，然后当前行设为上一行，当前列设为当前行的下一个待测位置。
>* 完成后返回到第二步。
### 4、N皇后问题核心问题：
* 如果判断当前放置皇后是否满足条件，把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置，这样便可以把问题的空间规模压缩为一维O(N)，在判断是否冲突时也很简单，首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了，其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。至于斜线冲突，通过观察可以发现所有在斜线上冲突的皇后的位置都有规律即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。这样某个位置是否可以放置皇后的问题已经解决。
* 下面要解决的是使用何种方法来找到所有的N皇后的解。上面说过该问题是回溯法的经典应用，所以可以使用回溯法来解决该问题，具体实现也有两个途径，递归和非递归。

### 5、N皇后问题的代码实现：
* 递归实现
```C++
#define N 8 //N皇后--8皇后为例

bool CanPlaceQueen(vector<int> qFlag, int row, int col)
{
	//对于row行，col列能否放置皇后进行判定，如果能则返回true
	for (int i = 0;i < row;i++)//当前位置是row行，则之前肯定已经有[0,...,row-1]行放置了皇后，对于每一个皇后一一进行判定
	{
		//如果两个皇后列数相等， 则直接判定不能放置，返回false
		//如果两个皇后列数差绝对值等于行数差绝对值，则这两个皇后在同一斜线上，也判定为不能放置，返回false
		if (qFlag[i] == col || (abs(row - i) == abs(col - qFlag[i])))
			return false;
	}
	//对于已经放置的row个皇后，如果都不冲突，则当前[row,col]可以放置皇后，返回true
	return true;
}

void queen(vector<int> qFlag, vector<vector<int>> &output, int row)
{
	//N皇后问题，
	//row[0,...,N-1]表示从第一行到第N行，
	//qFlag为N维向量，索引对应行数[0,...,N-1]，存储的值是皇后放置的列数[0,...,N-1]。
	//output 为X*N维向量， 每一行对应一种解，X未知。
	if (row == N)
	{
		output.push_back(qFlag);//row == N ，表示已经前面N层都放置好了皇后，输出当前解，然后回溯。
	}
	else
	{
		for (int i = 0;i < N;i++)
		{
			if (CanPlaceQueen(qFlag, row, i))//如果当前位置可以放置皇后，则放置皇后并修改flag。
			{
				qFlag[row] = i;//当前位置放置皇后，修改第row行对应的flag为放置的列数。
				queen(qFlag, output, row + 1);//往下一行继续搜寻
				//qFlag[row] = -1;//回溯法核心，在每次探索完之后，重置回溯之前的修改。
				//此行可以进行注释省略，主要原因是当前行的修改，对于回溯之后的情况没有任何影响，所以不需要进行重置，等待前一行的继续追溯，然后修改。
			}
		}
	}
	return;
}
```
* 非递归实现
```C++
#include<iostream>
#include<vector>
#include<string>
#include"VectorHelper.h"
using namespace std;
#define N 5

bool CanPlaceQueen(vector<int> qFlag, int row, int col)
{
	//对于row行，col列能否放置皇后进行判定，如果能则返回true
	for (int i = 0;i < row;i++)//当前位置是row行，则之前肯定已经有[0,...,row-1]行放置了皇后，对于每一个皇后一一进行判定
	{
		//如果两个皇后列数相等， 则直接判定不能放置，返回false
		//如果两个皇后列数差绝对值等于行数差绝对值，则这两个皇后在同一斜线上，也判定为不能放置，返回false
		if (qFlag[i] == col || (abs(row - i) == abs(col - qFlag[i])))
			return false;
	}
	//对于已经放置的row个皇后，如果都不冲突，则当前[row,col]可以放置皇后，返回true
	return true;
}

void queenNR(vector<int> qFlag, vector<vector<int>> &output)
{
	//N皇后问题，非递归实现
	//qFlag为N维向量，索引对应行数[0,...,N-1]，存储的值是皇后放置的列数[0,...,N-1]。
	//output 为X*N维向量， 每一行对应一种解，X未知。
	int row = 0;//从第一行开始找
	qFlag[row] = 0;//将第一行第一列放皇后，为后续的棋子选合适的位置
	while (row > -1)
	{
		if (row < N && qFlag[row] < N)
		{//如果行数，以及列数都满足要求，则可以继续找，否则达到最后一行， 或者达到某行的最后一列
			if (CanPlaceQueen(qFlag, row, qFlag[row]))
			{//如果当前行列可以放皇后，则放置皇后，从下一行第一列开始找
				row++;
				if (row<N)
				{
					qFlag[row] = 0;
				}
			}
			else
				//如果当前行列不能放置皇后，则继续找下一列
			{
				qFlag[row]++;
			}
		}
		else
		{
			if (row >= N)
			{//行数大于等于N，表示N个皇后都放置完毕，保存结果到output,并将qFlag清零。
				output.push_back(qFlag);
			}
			//如果row>=N会执行下面代码，因为虽然找到了N皇后问题的一个解，但是要找的是所有解，需要回溯，从当前放置皇后的下一列继续探测  
			//如果flag[row]>=N也会执行下面两行代码，就是说在当前行没有找到可以放置皇后的位置，于是回溯，从上一行皇后位置的下一列继续探测
			row--;//回溯至前一行
			if (row == -1)break;
			qFlag[row]++;//继续试探下一列
		}
	}
}
int main()
{
	vector<int> qFlag(N, -1);
	vector<vector<int>> res;
	queenNR(qFlag, res);
	for (int i = 0;i < res.size();i++)
	{
		VectorHelper::printVector(res[i]);
	}
	cout << res.size() << endl;
	system("pause");
 	return 0;
}
```
